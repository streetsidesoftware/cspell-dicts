from pathlib import Path
import re
import ast


def findFiles():
    files = Path('temp/python/cpython/Lib').glob('**/*.py')
    # files = Path('temp/python/cpython/Lib').glob('**/dataclasses.py')
    public_files = filter(lambda p: not (
        re.match(r'^_(?!_init__)', p.name) or re.match(
            r'.*\b(test_|_test|test|tests)\b', str(p))
    ), files)
    return public_files


def evalNode(astNode: ast.AST):
    for node in ast.iter_child_nodes(astNode):
        if isinstance(node, ast.FunctionDef) or isinstance(node, ast.ClassDef) or isinstance(node, ast.AsyncFunctionDef):
            name = node.name
            # yield '# ' + type(node).__name__ + ': ' + name
            if re.match('^_', name):
                continue
            yield name
            if isinstance(node, ast.ClassDef):
                if not node.col_offset:
                    yield from (name + '.' + method for method in evalNode(node))
        elif isinstance(node, ast.Assign):
            yield from evalAssign(node)
        # else:
        #     yield '# ' + type(node).__name__


def evalAssign(astExpression: ast.Assign):
    for target in astExpression.targets:
        if not isinstance(target, ast.Name) or re.match('^_', target.id):
            continue
        yield target.id


def evalFile(file: Path):
    text = open(file, "r").read()
    try:
        p = ast.parse(text)
        return evalNode(p)
    except:
        return ('# Error Reading ' + file.name)


print("""
########################
#
# This file is generated by scripts/fetch-python.sh and scripts/extractLib.py
# Do not manually edit this file, run the script instead.
#
########################
""")
for path in findFiles():
    print('# ' + str(path))
    # Add the file name and parent folder
    print(path.parent.name + '/' + path.name)
    for entry in evalFile(path):
        print(entry)
